红黑树（RBTree）的定义

1.任何一个节点都有颜色，黑色或者红色
	
2.根节点是黑色的
	
3.父子节点之间不能出现两个连续的红节点
	
4.任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等
	
5.空节点被认为是黑色的

RBTree在理论上还是一棵BST树，
它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1］。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)。



RBTree的查找操作就是BST的查找操作。



RBTree的旋转操作

旋转操作（Ratate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。
Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。




RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复，使得它符合RBTree的定义。



新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。



插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：

1.叔叔节点也为红色。
	
2.叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。

3.叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。




RBTree的删除操作

删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。



删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。



删除修复操作分为四种情况(删除黑节点后)：
	
1.待删除的节点的兄弟节点是红色的节点。
	
2.待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。
	
3.待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。
	
4.待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。




总结


操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。
整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。



适用场景

比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。
Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。